import {
  deleteFiles,
  findMarkedFiles,
  getAllFilePathsInFolder,
  writeFile,
} from '../util/fileUtils'
import { ProjectFile } from './projectFile'
import { Tokens } from './tokens'

const PHOENIX = 'phoenix'
export const PROJECT_FILENAME = `.${PHOENIX}rc.ts`
// Token replacement is important here to ensure this file doesn't include the marker.
export const REGENERATED_FILE_MARKER = `** Generated by ${PHOENIX} ** To edit, update ${PROJECT_FILENAME} and rebuild the project.`

interface ProjectParams {
  tokens?: Record<string, string>
  regeneratedFiles?: ProjectFiles
}

interface ProjectFiles {
  /** The key is the path of the generated file, relative to the project root. */
  [outputPath: string]: ProjectFile
}

export class Project {
  static fromTemplateFolder(folderPath: string): Project {
    const project = new Project()

    const filePaths = getAllFilePathsInFolder(folderPath)
    filePaths.forEach(filePath => {
      project.regeneratedFiles[filePath] = ProjectFile.textFileFromTemplate(`${folderPath}/${filePath}`)
    })

    return project
  }

  /**
   * The set of tokens which will be used during file generation.
   * The key is the token name and the value is the value which will be used in the generated file.
   */
  tokens: Tokens
  /** Defines the files are regenerated each time. */
  regeneratedFiles: ProjectFiles

  constructor(params: ProjectParams | undefined = undefined) {
    this.tokens = params?.tokens ?? {}
    this.regeneratedFiles = params?.regeneratedFiles ?? {}
  }

  regenerateFiles(): void {
    /* We can't just rely on the current set of files as there may be old files which were generated by a
     * previous iteration of the project. */
    deleteFiles(findMarkedFiles(REGENERATED_FILE_MARKER))

    Object.keys(this.regeneratedFiles).forEach((fileName) => {
      const projectFile = this.regeneratedFiles[fileName]

      const contents = projectFile.getFileContents({
        regeneratedFileMarker: REGENERATED_FILE_MARKER,
        ...this.tokens,
      })

      // Sense-check: regenerated files must always include the generated file marker somewhere.
      if (!contents.includes(REGENERATED_FILE_MARKER)) {
        throw new Error(
          `Regenerated file ${fileName} does not include the generated file marker '${REGENERATED_FILE_MARKER}`,
        )
      }

      writeFile(fileName, contents, { readOnly: true })
    })
  }
}
